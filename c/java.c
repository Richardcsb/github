/*类是一种引用类型*/
/*如果一个引用类型的数据域没有引用任何对象，那么这个数据域就有一个特殊的java值null*/
/*每个变量都代表一个储存值的内存位置声明一个变量时，就是在告诉编译器变量这个变量可以存放
什么类型的值，对基本类型来说，对应内存所储存的值对应内存所存储的值就是基本类型值。对引用变量来说
，对应的内存所存储的值是一个引用，对象的存储地址*/
/*静态变量被类中所有对象共享，静态方法不能访问类中的实例成员*/
/*如果想让一个类的所有实例共享数据，就要使用静态变量，也成类变量，静态变量将变量值存储在一个公共的内存地址*/
/*类中的常量是被该类的所有对象共享的，因此，常量声明应该为final static,例如Math类中的常量PI是如下定义的
final static double PI + 3.1415926;*/
/*如果一个变量或方法依赖于类的某个具体实例，那就应该将她定义为实例变量或则实例方法
如果一个变量或方法不依赖于类的某个具体实例，那就应该将她定义为静态变量或则静态方法*/
/*修饰符private只能应用在类的成员上，修饰符public可以应用在类或类的成员上，在局部变量上使用修饰符public和private都会导致编译错误*/
/*向方法传递对象参数
public static void printCircle(CircleWithPrivateDataFields c)
java 中只有一种参数传递方式：值传递在上面的代码中，myCircle的值被传递给printCircle方法，这个值就是一个对Circle对象的引用值*/
/*this 引用
关键字this引用对象自身，也可以在构造方法内部用于调用同一个类的其他构造方法*/
/*类的抽象是指将类的实现和类的使用分离开，实现的细节被封装并且对用户隐藏，这被称为类的封装*/
/*构造方法可以调用重载的构造方法或父类的构造方法，如果他们都没有被显式的调用，编译器就会自动将super()作为构造方法的第一条语句
一般情况下最好能为每个类提供一个无参的构造方法，一边对该类进行扩展，同时避免错误。*/
/*与实例方法一样静态方法也能被继承，但是静态方法不能被覆盖，如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义，的静态方法将被隐藏
可以使用语法：父类名.静态方法名调用隐藏的静态方法*/
/*方法重载可以发生在同一个类中也可以发生在由于继承而相关的不同类中*/
/*java中的所有类都继承来自java.lang.Object,如果一个类定义是没有指定继承性那么这个类的父类就被默认是Object*/
/*多态，面向对象程序设计的三大支柱是封装，继承和多态，首先先定义两个有用的术语：子类型和父类型，一个类实际上是定义了一种类型，子类定义的类型称为子类型
subtype,父类定义的类型称为父类型*/
/*父类，使用父类对象的地方都可以使用子类的对象，这就是通常所说的多态，多态意味着父类型的变量可以引用子类型的对象*/
/*捕获到异常停止程序System.exit(1)一般放在catch块中,System.exit(0)是正常停止程序*/
/*异常是对象，而对像都采用类来定义，异常的根类是java.lang.Throwable*/
/*声明异常的关键字是throws,抛出异常的关键字是throw*/
/*如果父类中没有声明异常，那么就不能在子类中对其进行继承来声明异常*/
/*声明异常
ILLegalArgumentException ex = new ILLegament#xception("Wrong Argument");
throw ex;
或者
throw new ILLegalArgumentException("Wrong Argument");
*/
/*捕获异常
try{
  statements;
}
catch (Exception1 exVar1){
  handler for excedption1
}
catch (Exception2 exVar1){
  handler for excedption2
}
...
catch (ExceptionN exVarN){
  handler for exceptionN
}
*/
/*从一个通用的父类可以派生出各种异常类，如果一个catch块可以捕获一个父类的的异常对象，他就能捕获那个父类的所有子类的异常对象。
如果父类的catch块出现在子类的catch块之前，就会导致编译错误*/
/*在不可预料的错误状况中应该使用try-catch,但是在可预料的简单的情况下就不要使用了*/
/*finally子句，有时候，不论异常是否出现或者被捕获，都希望执行某些代码
finally语法如下：
try{
  statement
}
catch(TheException){
  handling ex;
}
finally{
  finalStatements;
}
*/
/*在程序中不要使用绝对路径，如果在windows中写了绝对路径在其它系统中就用不了了*/
/*一个包含抽象方法的类必须是抽象类，抽象类的构造方法定义为protected,因为他只能被子类使用，创建一个子类的实例时它的父类构造方法被调用以初始化父类中定义的数据域*/
/*由于接口中所有的的数据域都是public static final而且所有的方法都是public abstract,所以可以忽略*/
/*在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。
 一个类只能继承一个抽象类，而一个类却可以实现多个接口,当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类*/
